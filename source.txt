/*
 * File:  src/main/java/net/ukrcom/cip_gov_ua_getter/DomainValidatorUtil.java
 */
/*
 * Copyright 2025 olden
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package net.ukrcom.cip_gov_ua_getter;
import com.ibm.icu.text.SpoofChecker;
import org.apache.commons.validator.routines.DomainValidator;
import org.apache.commons.validator.routines.InetAddressValidator;
import org.slf4j.Logger;
import java.net.IDN;
import java.time.LocalDateTime;
import java.util.HashSet;
import java.util.Set;
import java.util.concurrent.ConcurrentHashMap;
import java.util.regex.Matcher;
import java.util.regex.Pattern;
public class DomainValidatorUtil {
    private static final ConcurrentHashMap<String, String> SKELETON_CACHE = new ConcurrentHashMap<>();
    private static final ConcurrentHashMap<String, Boolean> TLD_CACHE = new ConcurrentHashMap<>();
    // Регулярний вираз для виділення валідних доменів, включаючи повну підтримку Unicode і подвійних дефісів
    /*
        Розбір DOMAIN_CLEAN_PATTERN
        1. [a-zA-Z0-9\\p{L}\\p{M}*-]+
           - Матчує першу частину домену (до крапки), дозволяючи дефіси.
           - [a-zA-Z0-9\\p{L}\\p{M}*-]: Символьний клас:
             - a-zA-Z: Латинські літери.
             - 0-9: Цифри.
             - \\p{L}: Unicode-літери (кирилиця, китайські ієрогліфи тощо).
             - \\p{M}*: Нуль або більше діакритичних знаків.
             - -: Дефіс (дозволяє --).
           - +: Один або більше символів.
           - Приклад: nasepravda, xn--b1akbpgy3fwa, приклад.
        2. (?:\\.[a-zA-Z0-9\\p{L}\\p{M}*-]+)+
           - Матчує одну або більше частин після крапки (TLD або багаторівневий домен).
           - \\.: Буквальна крапка.
           - [a-zA-Z0-9\\p{L}\\p{M}*-]+: Символьний клас, як вище.
           - +: Одна або більше груп із крапкою.
           - Приклад: .cz, .xn--p1acf, .co.uk.
     */
    private static final Pattern DOMAIN_CLEAN_PATTERN = Pattern.compile(
            "[a-zA-Z0-9\\p{L}\\p{M}*-]+"
            + "(?:\\.[a-zA-Z0-9\\p{L}\\p{M}*-]+)+"
    );
    public static Set<String> validateDomain(String rawDomain, String[] serviceSubdomains, String sourceDomain,
            DomainValidator domainValidator, InetAddressValidator ipValidator,
            SpoofChecker spoofChecker, Logger logger, boolean includeBlockedDomain,
            LocalDateTime dateTime, Set<BlockedDomain> blockedDomains) {
        Set<String> validDomains = new HashSet<>();
        try {
            // Очищаємо вхідну строку від протоколів і пробілів
            String cleanedInput = rawDomain
                    .trim()
                    .replaceAll("(?i)^(https?://|ftp://)", "") // Видаляємо протоколи
                    .replaceAll("\\s+", "") // Видаляємо пробіли
                    .toLowerCase();
            // Витягуємо всі валідні домени зі строки
            Matcher matcher = DOMAIN_CLEAN_PATTERN.matcher(cleanedInput);
            boolean found = false;
            while (matcher.find()) {
                found = true;
                String domain = matcher.group();
                logger.debug("Cleaned domain: {} → {}", rawDomain, domain);
                // Перевірка на порожній домен або надмірну довжину
                if (domain.isBlank() || domain.length() > 255) {
                    logger.warn("Skipping domain due to invalid length: {}", domain);
                    continue;
                }
                // Видаляємо субдомени зі списку serviceSubdomains
                for (String service : serviceSubdomains) {
                    if (domain.startsWith(service + ".")) {
                        domain = domain.substring(service.length() + 1);
                        break;
                    }
                }
                // Видаляємо шляхи, порти, параметри
                int endIndex = domain.indexOf("/");
                if (endIndex != -1) {
                    domain = domain.substring(0, endIndex);
                }
                endIndex = domain.indexOf(":");
                if (endIndex != -1) {
                    domain = domain.substring(0, endIndex);
                }
                endIndex = domain.indexOf("?");
                if (endIndex != -1) {
                    domain = domain.substring(0, endIndex);
                }
                // Пропускаємо sourceDomain, якщо він є
                if (sourceDomain != null && domain.equals(sourceDomain)) {
                    logger.warn("Skipping source domain: {}", domain);
                    continue;
                }
                // Конвертуємо в Punycode
                String idnDomain = IDN.toASCII(domain, IDN.ALLOW_UNASSIGNED);
                if (idnDomain.length() > 255) {
                    logger.warn("Skipping domain after IDN conversion due to length: {}", idnDomain);
                    continue;
                }
                // Перевіряємо валідність IDN-домену
                if (domainValidator.isValid(idnDomain)) {
                    String tld = extractTld(idnDomain);
                    if (tld == null) {
                        logger.warn("Invalid TLD (null) for domain: {}", idnDomain);
                        continue;
                    }
                    // Перевіряємо TLD через кеш
                    Boolean isValidTld = TLD_CACHE.computeIfAbsent(tld, k -> domainValidator.isValidTld(k));
                    if (!isValidTld) {
                        logger.warn("Invalid TLD '{}' for domain: {}", tld, idnDomain);
                        continue;
                    }
                    validDomains.add(idnDomain);
                    if (includeBlockedDomain) {
                        blockedDomains.add(new BlockedDomain(idnDomain, true, dateTime));
                    }
                    logger.info("Valid IDN domain: {}", idnDomain);
                } else if (ipValidator.isValid(domain)) {
                    logger.warn("Skipping IP address: {}", domain);
                    continue;
                } else {
                    logger.warn("Invalid IDN domain: {}", domain);
                }
                // Обробка гомогліфів для нелатинських символів
                boolean hasNonLatin = domain.chars().anyMatch(c -> c > 127);
                if (hasNonLatin) {
                    String latinized = SKELETON_CACHE.computeIfAbsent(domain, spoofChecker::getSkeleton);
                    String latinizedIdn = IDN.toASCII(latinized, IDN.ALLOW_UNASSIGNED).toLowerCase();
                    if (latinizedIdn.length() > 255) {
                        logger.warn("Skipping latinized domain due to length: {}", latinizedIdn);
                    } else if (domainValidator.isValid(latinizedIdn) && !latinizedIdn.equals(idnDomain)) {
                        String latinizedTld = extractTld(latinizedIdn);
                        if (latinizedTld == null) {
                            logger.warn("Invalid TLD (null) for latinized domain: {}", latinizedIdn);
                            continue;
                        }
                        // Перевіряємо TLD через кеш для латинізованого домену
                        Boolean isValidLatinizedTld = TLD_CACHE.computeIfAbsent(latinizedTld, k -> domainValidator.isValidTld(k));
                        if (!isValidLatinizedTld) {
                            logger.warn("Invalid TLD '{}' for latinized domain: {}", latinizedTld, latinizedIdn);
                            continue;
                        }
                        validDomains.add(latinizedIdn);
                        if (includeBlockedDomain) {
                            blockedDomains.add(new BlockedDomain(latinizedIdn, true, dateTime));
                        }
                        logger.info("Valid latinized domain: {} (from {} ⮕ {})", latinizedIdn, domain, latinized);
                    } else {
                        logger.debug("Latinized domain invalid or identical: {} (from {} ⮕ {})", latinized, domain, latinized);
                    }
                }
            }
            if (!found) {
                logger.warn("No valid domain found in: {}", rawDomain);
            }
        } catch (Exception e) {
            logger.warn("Error processing domain {}: {}", rawDomain, e.getMessage());
        }
        return validDomains;
    }
    private static String extractTld(String domain) {
        if (domain == null || domain.isEmpty()) {
            return null;
        }
        int lastDot = domain.lastIndexOf('.');
        if (lastDot == -1 || lastDot == domain.length() - 1) {
            return null;
        }
        return domain.substring(lastDot);
    }
}
/*
 * File:  src/main/java/net/ukrcom/cip_gov_ua_getter/PlaycityParser.java
 */
/*
 * Copyright 2025 olden
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package net.ukrcom.cip_gov_ua_getter;
import java.nio.file.Path;
import java.util.Arrays;
import java.util.Properties;
import java.util.Set;
import java.util.TreeSet;
/**
 * Парсер для отримання списку доменів із сервісів держави-агресора.
 *
 * @author olden
 */
public class PlaycityParser extends AbstractPDFParser {
    private final String[] urlPdfs;
    public PlaycityParser(Properties properties, boolean debug) {
        super(properties, debug);
        this.sourceDomain = "nkek.gov.ua";
        this.urlPdfs = Arrays.stream(properties.getProperty("urlPdfs", "").split(","))
                .map(String::trim)
                .filter(s -> !s.isEmpty())
                .toArray(String[]::new);
    }
    @Override
    public Set<BlockedDomain> parse() {
        Set<BlockedDomain> domains = new TreeSet<>(new BlockedDomainComparator());
        for (String targetUrl : this.urlPdfs) {
            if (targetUrl == null || targetUrl.isEmpty()) {
                continue;
            }
            try {
                disableSSLCertificateVerification();
                Path primaryPdfPath = manualDir.resolve(targetUrl.replaceAll("[:/]", "-"));
                downloadPdf(targetUrl, primaryPdfPath.toString());
                logger.info("Successfully downloaded PDF from {} to {}", targetUrl, primaryPdfPath);
                domains.addAll(extractDomainsFromPDF(primaryPdfPath.toString()));
                if (debug) {
                    logger.debug("Extracted {} domains from PDF", domains.size());
                }
            } catch (Exception e) {
                logger.error("Error parsing aggressor services: {}", e.getMessage(), e);
            }
        }
        return domains;
    }
    @Override
    public String prepareDocument(String text) {
        return text
                .replaceAll("\n", " ")
                .replaceAll("\\d+\\s*\\.\\s*http", " http")
                .replaceAll("\\s+", " ");
    }
}
/*
 * File:  src/main/java/net/ukrcom/cip_gov_ua_getter/AbstractPDFParser.java
 */
/*
 * Copyright 2025 olden
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package net.ukrcom.cip_gov_ua_getter;
import com.ibm.icu.text.SpoofChecker;
import java.io.File;
import org.apache.commons.validator.routines.DomainValidator;
import org.apache.commons.validator.routines.InetAddressValidator;
import org.apache.pdfbox.Loader;
import org.apache.pdfbox.pdmodel.PDDocument;
import org.apache.pdfbox.text.PDFTextStripper;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import javax.net.ssl.*;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.net.URL;
import java.nio.channels.Channels;
import java.nio.channels.ReadableByteChannel;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.security.SecureRandom;
import java.security.cert.X509Certificate;
import java.time.LocalDateTime;
import java.util.Arrays;
import java.util.Properties;
import java.util.Set;
import java.util.TreeSet;
import java.util.regex.Matcher;
import java.util.regex.Pattern;
/**
 * Парсер для отримання списку доменів із сервісів держави-агресора.
 *
 * @author olden
 */
public abstract class AbstractPDFParser {
    protected static final Logger logger = LoggerFactory.getLogger(AbstractPDFParser.class);
    private static final DomainValidator DOMAIN_VALIDATOR = DomainValidator.getInstance(true);
    private static final InetAddressValidator IP_VALIDATOR = InetAddressValidator.getInstance();
    private static final SpoofChecker SPOOF_CHECKER = new SpoofChecker.Builder().build();
    protected final Properties properties;
    protected final Path manualDir;
    protected final boolean debug;
    protected String sourceDomain;
    protected String[] serviceSubdomains;
    public AbstractPDFParser(Properties properties, boolean debug) {
        this.properties = properties;
        this.debug = debug;
        String manualDirStr = properties.getProperty("AggressorServices_prescript_to", "./PRESCRIPT").trim();
        this.manualDir = Paths.get(manualDirStr).normalize();
        try {
            Files.createDirectories(this.manualDir);
            logger.debug("Ensured directory exists: {}", this.manualDir);
        } catch (IOException e) {
            logger.error("Failed to create directory {}: {}", this.manualDir, e.getMessage(), e);
            throw new RuntimeException("Cannot create directory: " + this.manualDir, e);
        }
        String subdomains = properties.getProperty("SERVICE_SUBDOMAINS",
                "www,ftp,mail,api,blog,shop,login,admin,web,secure,m,mobile,app,dev,test,m");
        this.serviceSubdomains = Arrays.stream(subdomains.split(","))
                .map(String::trim)
                .filter(s -> !s.isEmpty())
                .filter(s -> {
                    boolean valid = s.matches("[a-zA-Z0-9-]+");
                    if (!valid && debug) {
                        logger.debug("Invalid subdomain skipped: {}", s);
                    }
                    return valid;
                })
                .toArray(String[]::new);
        if (serviceSubdomains.length == 0) {
            logger.warn("No valid service subdomains defined in SERVICE_SUBDOMAINS");
        }
    }
    abstract public Set<BlockedDomain> parse();
    protected void disableSSLCertificateVerification() throws Exception {
        TrustManager[] trustAllCerts = new TrustManager[]{
            new X509TrustManager() {
                @Override
                public X509Certificate[] getAcceptedIssuers() {
                    return null;
                }
                @Override
                public void checkClientTrusted(X509Certificate[] certs, String authType) {
                }
                @Override
                public void checkServerTrusted(X509Certificate[] certs, String authType) {
                }
            }
        };
        SSLContext sc = SSLContext.getInstance("SSL");
        sc.init(null, trustAllCerts, new SecureRandom());
        HttpsURLConnection.setDefaultSSLSocketFactory(sc.getSocketFactory());
        HostnameVerifier allHostsValid = (hostname, session) -> true;
        HttpsURLConnection.setDefaultHostnameVerifier(allHostsValid);
    }
    protected void downloadPdf(String pdfUrl, String destinationPath) throws
            IOException {
        Path destPath = Paths.get(destinationPath);
        if (Files.exists(destPath)) {
            logger.debug("PDF already exists: {}", destPath);
            return;
        }
        Files.createDirectories(destPath.getParent());
        URL url = new URL(pdfUrl);
        try (InputStream in = url.openStream();
             ReadableByteChannel rbc = Channels.newChannel(in);
             FileOutputStream fos = new FileOutputStream(destPath.toFile())) {
            fos.getChannel().transferFrom(rbc, 0, Long.MAX_VALUE);
        }
        logger.debug("Downloaded PDF to: {}", destPath);
    }
    public String prepareDocument(String text) {
        return text.replaceAll("\n", "");
    }
    protected Set<BlockedDomain> extractDomainsFromPDF(String filePath) {
        Set<BlockedDomain> domains = new TreeSet<>(new BlockedDomainComparator());
        try {
            File file = new File(filePath);
            try (PDDocument document = Loader.loadPDF(file)) {
                PDFTextStripper stripper = new PDFTextStripper();
                String text = stripper.getText(document);
                String cleanedText = prepareDocument(text);
                logger.debug("Document: {}", cleanedText);
                String domainPattern = "(?:https?://(?:www\\.)?"
                        + "(?:[-a-zA-Z0-9@:%._\\+~#=]|[-\\p{L}\\p{M}*]{1,256})"
                        + "\\.(?:[a-zA-Z0-9()]|[\\p{L}\\p{M}*]){1,6}\\b"
                        + "(?:[-a-zA-Z0-9()@:%_\\+.~#?&//=]*)|"
                        + "\\b(?:[a-zA-Z0-9\\p{L}\\p{M}*]"
                        + "(?:[a-zA-Z0-9\\p{L}\\p{M}*-]*[a-zA-Z0-9\\p{L}\\p{M}*])?\\.)+"
                        + "(?:[a-zA-Z]{2,}|[\\p{L}\\p{M}*]{2,})"
                        + "(?:\\/[-a-zA-Z0-9@:%_\\+.~#?&//=]*)?\\b)";
                Pattern domainRegex = Pattern.compile(domainPattern);
                Matcher domainMatcher = domainRegex.matcher(cleanedText);
                while (domainMatcher.find()) {
                    String match = domainMatcher.group();
                    DomainValidatorUtil.validateDomain(
                            match, serviceSubdomains, sourceDomain, DOMAIN_VALIDATOR, IP_VALIDATOR, SPOOF_CHECKER, logger,
                            true, LocalDateTime.now(), domains);
                }
            }
        } catch (IOException e) {
            logger.error("Error processing PDF file {}: {}", filePath, e.getMessage(), e);
        }
        return domains;
    }
}
/*
 * File:  src/main/java/net/ukrcom/cip_gov_ua_getter/Cip_gov_ua_getter.java
 */
/*
 * Copyright 2025 olden
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package net.ukrcom.cip_gov_ua_getter;
import java.io.FileInputStream;
import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.attribute.FileTime;
import java.time.LocalDateTime;
import java.time.ZoneId;
import java.time.format.DateTimeFormatter;
import java.time.format.DateTimeParseException;
import java.util.Properties;
import org.json.JSONArray;
import org.json.JSONException;
import org.json.JSONObject;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import ch.qos.logback.classic.Level;
import java.io.File;
import java.io.InputStreamReader;
import java.nio.charset.StandardCharsets;
import java.util.Arrays;
import java.util.Set;
/**
 * Консольна утиліта для збору та обробки розпоряджень про блокування доменів.
 *
 * @author olden
 */
public class Cip_gov_ua_getter {
    private static final Logger logger = LoggerFactory.getLogger(Cip_gov_ua_getter.class);
    private static final DateTimeFormatter ISO_FORMATTER = DateTimeFormatter.ISO_DATE_TIME;
    /**
     * Основний процес.
     *
     * @param args аргументи командного рядка: шлях до cip.gov.ua.properties
     * (опціонально), --debug або -d для вмикання дебаг-логів
     */
    public static void main(String[] args) {
        // Налаштування дебаг-логування
        boolean debug = false;
        String configPath = "cip.gov.ua.properties";
        for (String arg : args) {
            if (arg.equals("--debug") || arg.equals("-d")) {
                debug = true;
            } else if (!arg.isEmpty()) {
                configPath = arg;
            }
        }
        if (debug) {
            ch.qos.logback.classic.Logger rootLogger
                    = (ch.qos.logback.classic.Logger) LoggerFactory.getLogger(Logger.ROOT_LOGGER_NAME);
            rootLogger.setLevel(Level.DEBUG);
            logger.debug("Debug logging enabled");
        }
        try {
            // Завантаження конфігурації
            Properties prop = new Properties();
//            try (InputStream input = new FileInputStream(configPath)) {
            try (InputStreamReader input = new InputStreamReader(new FileInputStream(configPath), StandardCharsets.UTF_8)) {
                prop.load(input);
                logger.debug("Loaded configuration from: {}", configPath);
            } catch (IOException e) {
                logger.error("Failed to load config from {}: {}", configPath, e.getMessage(), e);
                throw new RuntimeException("Failed to load config", e);
            }
            prop.setProperty("debug", debug ? "true" : "false");
            // Завантаження ключових слів для фільтрації
            String banKeywordsStr = prop.getProperty("ban_keywords", "блокування|обмеження доступу|реалізацію.*обмежувальних");
            String unbanKeywordsStr = prop.getProperty("unban_keywords", "розблокування|припинення тимчасового");
            String[] banKeywords = banKeywordsStr.split("\\|");
            String[] unbanKeywords = unbanKeywordsStr.split("\\|");
            if (banKeywords.length == 0) {
                logger.warn("No ban_keywords defined in configuration, using default: блокування");
                banKeywords = new String[]{"блокування"};
            }
            if (unbanKeywords.length == 0) {
                logger.warn("No unban_keywords defined in configuration, using default: розблокування");
                unbanKeywords = new String[]{"розблокування"};
            }
            logger.debug("Loaded ban_keywords: {}", Arrays.toString(banKeywords));
            logger.debug("Loaded unban_keywords: {}", Arrays.toString(unbanKeywords));
            BlockedObjects bo = new BlockedObjects(prop).getBlockedDomainNames();
            CGUGetter cguGetter = new CGUGetter(prop);
            ParseCGUArticlesJson parseCGUArticlesJson = new ParseCGUArticlesJson(cguGetter.getJsonBody());
            JSONArray posts = parseCGUArticlesJson.getPosts();
            if (posts.isEmpty()) {
                logger.warn("No posts found in JSON response");
                bo.storeState();
                return;
            }
            for (int i = 0; i < posts.length(); i++) {
                JSONObject post = posts.getJSONObject(i);
                String title = post.getString("title");
                // Ігноруємо непубліковані пости
                if (!post.getString("status").equalsIgnoreCase("PUBLISHED")) {
                    logger.warn("Skipping unpublished post: {} - {}", post.getString("date"), title);
                    continue;
                }
                /*
                // Перевіряємо, чи пост стосується блокування/обмеження
                if (!(title.matches(".*блокування.*")
                        || title.matches(".*обмеження доступу.*")
                        || title.matches(".*реалізацію.*обмежувальних.*"))) {
                    logger.warn("Skipping unrelated post: {} - {}", post.getString("date"), title);
                    continue;
                }
                // Визначаємо дію (блокувати чи розблокувати)
                boolean block = !title.matches(".*розблокування.*") && !title.matches(".*припинення тимчасового.*");
                 */
                // Перевіряємо, чи пост стосується блокування/обмеження
                boolean isRelevant = false;
                for (String keyword : banKeywords) {
                    if (title.matches(".*" + keyword + ".*")) {
                        isRelevant = true;
                        break;
                    }
                }
                if (!isRelevant) {
                    logger.warn("Skipping unrelated post: {} - {}", post.getString("date"), title);
                    continue;
                }
                // Визначаємо дію (блокувати чи розблокувати)
                boolean block = true;
                for (String keyword : unbanKeywords) {
                    if (title.matches(".*" + keyword + ".*")) {
                        block = false;
                        break;
                    }
                }
                // Обробляємо вкладення
                JSONArray postAttachments = post.getJSONArray("attachments");
                for (int j = 0; j < postAttachments.length(); j++) {
                    JSONObject attachment = postAttachments.getJSONObject(j);
                    String id = String.valueOf(attachment.getInt("id"));
                    String mimeType = attachment.getString("mimeType");
                    String fileName = attachment.getString("originalFileName");
                    GetPrescript gp = new GetPrescript(prop, id, mimeType)
                            .setOrigFileName(fileName)
                            .getPrescriptFrom()
                            .storePrescriptTo();
                    // Оновлюємо дату файлу відповідно до post.date
                    setFileDate(new File(gp.getFileName()), post.getString("date"));
                    if (!mimeType.equalsIgnoreCase("text/plain")) {
                        logger.info("{} {} {} {} \"{}\"",
                                LocalDateTime.now(), post.getString("date"), block ? "+" : "-", id, fileName);
                        continue;
                    }
                    for (String domain : gp.getBodyPrescript()) {
                        if (domain.length() > 255) {
                            logger.warn("Skipping domain due to invalid length: {}", domain);
                            continue;
                        }
                        BlockedDomain bd = new BlockedDomain(domain, block, post.getString("date"));
                        if (bo.addBlockedDomainName(bd)) {
                            logger.info("{} {} [ {} \"{}\"]",
                                    LocalDateTime.now(), bd, id, fileName);
                        }
                    }
                    if (!gp.isLocalRead()) {
                        try {
                            Thread.sleep(1000 + (long) (Math.random() * 1000)); // 1-2 секунди
                        } catch (InterruptedException e) {
                            logger.error("Interrupted during delay: {}", e.getMessage(), e);
                            Thread.currentThread().interrupt();
                        }
                    }
                }
            }
            // Parse aggressor services
            AggressorServicesParser parser = new AggressorServicesParser(prop, debug);
            Set<BlockedDomain> aggressorDomains = parser.parse();
            for (BlockedDomain bd : aggressorDomains) {
                bo.addBlockedDomainName(bd);
            }
            // Parse NKEK.GOV.UA prescripts
            PlaycityParser parserNkek = new PlaycityParser(prop, debug);
            Set<BlockedDomain> nkekDomains = parserNkek.parse();
            for (BlockedDomain bd : nkekDomains) {
                bo.addBlockedDomainName(bd);
            }
            // Зберігаємо результати
            bo.storeState();
            logger.info("Successfully stored blocked domains state");
        } catch (IOException e) {
            logger.error("Failed to process articles: {}", e.getMessage(), e);
            throw new RuntimeException("Failed to process articles", e);
        } catch (JSONException e) {
            logger.error("Failed to parse JSON: {}", e.getMessage(), e);
            throw new RuntimeException("Failed to parse JSON", e);
        }
    }
    /**
     * Встановлює дату модифікації файлу на основі дати з поста. Нічого не
     * робить, якщо файл недоступний або дата некоректна.
     *
     * @param file файл для оновлення
     * @param dateStr дата у форматі ISO 8601 (наприклад,
     * "2023-12-07T10:44:00Z")
     */
    private static void setFileDate(File file, String dateStr) {
        if (!file.exists() || !file.canWrite()) {
            logger.warn("Cannot set date for file {}: file does not exist or is not writable", file.getAbsolutePath());
            return;
        }
        try {
            LocalDateTime dateTime = LocalDateTime.parse(dateStr, ISO_FORMATTER);
            long millis = dateTime.atZone(ZoneId.systemDefault()).toInstant().toEpochMilli();
            Files.setLastModifiedTime(file.toPath(), FileTime.fromMillis(millis));
            logger.debug("Set file date for {} to {}", file.getAbsolutePath(), dateStr);
        } catch (DateTimeParseException e) {
            logger.warn("Failed to parse date '{}' for file {}: {}", dateStr, file.getAbsolutePath(), e.getMessage());
        } catch (IOException e) {
            logger.warn("Failed to set date for file {}: {}", file.getAbsolutePath(), e.getMessage());
        }
    }
}
/*
 * File:  src/main/java/net/ukrcom/cip_gov_ua_getter/BlockedDomainComparator.java
 */
/*
 * Copyright 2025 olden
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package net.ukrcom.cip_gov_ua_getter;
import java.util.Comparator;
/**
 * Компаратор для формування TreeSet з об'єктів jBlockedDomain. Порядок
 * сортування задається по імені домена, як основному крітерію, далі по даті та
 * часу видання розпорядження. Якщо ж дата та час збігаються то першим стає
 * розпорядження, що блокує домен.
 *
 * @author olden
 */
public class BlockedDomainComparator implements Comparator {
    @Override
    public int compare(Object o1, Object o2) {
        BlockedDomain d1 = (BlockedDomain) o1;
        BlockedDomain d2 = (BlockedDomain) o2;
        int compare = d1.getDomainName().compareTo(d2.getDomainName());
        if (compare != 0) {
            return compare;
        }
        compare = d1.getDateTime().compareTo(d2.getDateTime());
        if (compare != 0) {
            return compare;
        }
        return Boolean.compare(d1.getIsBlocked(), d2.getIsBlocked());
    }
    /*
    public int compare(Object o1, Object o2) {
        int retVal = 0;
        BlockedDomain d1 = (BlockedDomain) o1;
        BlockedDomain d2 = (BlockedDomain) o2;
        int compareTo = d1.getDomainName().compareTo(d2.getDomainName());
        compareTo = (compareTo > 0 ? 1 : (compareTo < 0 ? -1 : 0));
        if (compareTo != 0) {
            retVal = compareTo;
        } else {
            if (d1.getDateTime().toEpochSecond(ZoneOffset.UTC) > d2.getDateTime().toEpochSecond(ZoneOffset.UTC)) {
                retVal = 1;
            } else if (d1.getDateTime().toEpochSecond(ZoneOffset.UTC) < d2.getDateTime().toEpochSecond(ZoneOffset.UTC)) {
                retVal = -1;
            } else {
                if (d1.getIsBlocked() && !d2.getIsBlocked()) {
                    retVal = 1;
                } else if (!d1.getIsBlocked() && d2.getIsBlocked()) {
                    retVal = -1;
                } else {
                    retVal = 0;
                }
            }
        }
        return retVal;
    }
     */
}
/*
 * File:  src/main/java/net/ukrcom/cip_gov_ua_getter/BlockedDomain.java
 */
/*
 * Copyright 2025 olden
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package net.ukrcom.cip_gov_ua_getter;
import java.time.Instant;
import java.time.LocalDateTime;
import java.time.ZoneId;
import java.time.format.DateTimeFormatter;
public class BlockedDomain {
    protected String domainName;
    protected boolean isBlocked;
    protected LocalDateTime dateTime;
    /**
     * Конструктор класа.
     *
     * @param dn - ім'я домена
     * @param b - статус операції над доменом
     * @param dt - дата в форматі LocalDateTime
     */
    public BlockedDomain(String dn, boolean b, LocalDateTime dt) {
        if (dn == null || dn.isBlank() || dn.length() > 255) {
            throw new IllegalArgumentException("Domain name is invalid or exceeds 255 characters: " + dn);
        }
        this.domainName = dn;
        this.isBlocked = b;
        this.dateTime = dt;
    }
    /**
     * Конструктор класа.
     *
     * @param dn - ім'я домена
     * @param b - статус операції над доменом
     * @param s - дата в текстовому форматі. Береться з атрибута date.
     */
    public BlockedDomain(String dn, boolean b, String s) {
        if (dn == null || dn.isBlank() || dn.length() > 255) {
            throw new IllegalArgumentException("Domain name is invalid or exceeds 255 characters: " + dn);
        }
        this.domainName = dn;
        this.isBlocked = b;
        /*
        this.dateTime = LocalDateTime.parse(
                s.replaceAll("Z$", "")
        );
         */
        this.dateTime = LocalDateTime.parse(s, DateTimeFormatter.ISO_DATE_TIME);
    }
    /**
     * Конструктор класа. Статус - блокування. Дата - початок епохи.
     *
     * @param dn - ім'я домена
     */
    public BlockedDomain(String dn) {
        if (dn == null || dn.isBlank() || dn.length() > 255) {
            throw new IllegalArgumentException("Domain name is invalid or exceeds 255 characters: " + dn);
        }
        this.domainName = dn;
        this.isBlocked = true;
        this.dateTime = Instant
                .ofEpochMilli(0)
                .atZone(
                        ZoneId.systemDefault()
                )
                .toLocalDateTime();
    }
    /**
     * Повертає ім'я домена.
     *
     * @return
     */
    public String getDomainName() {
        return domainName;
    }
    /**
     * Встановлює ім'я домена.
     *
     * @param s
     */
    public void setDomainName(String s) {
        this.domainName = s;
    }
    /**
     * Повертає статус.
     *
     * @return
     */
    public boolean getIsBlocked() {
        return this.isBlocked;
    }
    /**
     * Встановлює статус.
     *
     * @param b
     */
    public void setIsBlocked(boolean b) {
        this.isBlocked = b;
    }
    /**
     * Повертає дату та час.
     *
     * @return
     */
    public LocalDateTime getDateTime() {
        return this.dateTime;
    }
    /**
     * Встановлює дату та час з LocalDateTime.
     *
     * @param d
     */
    public void setDateTime(LocalDateTime d) {
        this.dateTime = d;
    }
    /**
     * Встановлює дату та час, аналізуючи строку.
     *
     * @param s
     */
    public void setDateTime(String s) {
        this.dateTime = LocalDateTime.parse(s);
    }
    /**
     * Повертає стан екземпляра класа в текстовому вигляді.
     *
     * @return
     */
    @Override
    public String toString() {
        return "[".concat(getDateTime().toString())
                .concat(getIsBlocked() ? " + " : " - ")
                .concat(getDomainName())
                .concat("]");
    }
}
/*
 * File:  src/main/java/net/ukrcom/cip_gov_ua_getter/ParseCGUArticlesJson.java
 */
/*
 * Copyright 2025 olden
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package net.ukrcom.cip_gov_ua_getter;
import org.json.JSONArray;
import org.json.JSONException;
import org.json.JSONObject;
/**
 * Клас, що розбирає JSON з переліком розпоряджень.
 *
 * @author olden
 */
public class ParseCGUArticlesJson {
    protected final JSONObject json;
    protected final JSONArray posts;
    /**
     * Конструктор класа. Розбираємо сформований JSON з розпорядженнями.
     *
     * @param json_data
     * @throws JSONException
     */
    public ParseCGUArticlesJson(String json_data) throws JSONException {
        this.json = new JSONObject(json_data);
        this.posts = json.getJSONArray("posts");
    }
    /**
     * Повертаємо масив з розібраними й відокремленими один від одного
     * розпорядженнями, для подальшого аналізу.
     *
     * @return @throws JSONException
     */
    public JSONArray getPosts() throws JSONException {
        return this.posts;
    }
}
/*
 * File:  src/main/java/net/ukrcom/cip_gov_ua_getter/GetPrescript.java
 */
/*
 * Copyright 2025 olden
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package net.ukrcom.cip_gov_ua_getter;
import com.ibm.icu.text.SpoofChecker;
import com.microsoft.playwright.*;
import com.microsoft.playwright.options.LoadState;
import org.apache.commons.validator.routines.DomainValidator;
import org.apache.commons.validator.routines.InetAddressValidator;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import java.io.File;
import java.io.FileOutputStream;
import java.io.FileWriter;
import java.io.IOException;
import java.net.URI;
import java.net.URISyntaxException;
import java.nio.charset.StandardCharsets;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.util.Arrays;
import java.util.HashSet;
import java.util.Map;
import java.util.Properties;
import java.util.Set;
/**
 * Клас зчитує перелік доменів з відповідних text/plain файлів у розпорядженнях.
 *
 * @author olden
 */
public class GetPrescript {
    private static final Logger logger = LoggerFactory.getLogger(GetPrescript.class);
    private static final long MAX_FILE_SIZE_BYTES_DEFAULT = 15_728_640; // 15 МБ
    protected final String urlPrescript;
    protected String bodyPrescript;
    protected String id;
    protected final Path storePrescriptTo;
    protected String origFileName;
    private final String userAgent;
    private final String secChUa;
    private final Properties prop;
    private final String mimeType;
    private final boolean debug;
    private final String[] serviceSubdomains;
    private final long maxFileSizeBytes;
    // Спільний JavaScript-код для AJAX-запиту
    private static final String FETCH_SCRIPT_TEMPLATE = """
            const response = await fetch('%s', {
                method: 'GET',
                headers: {
                    'Accept': 'text/plain, */*',
                    'Sec-Ch-Ua': '%s',
                    'Sec-Fetch-Dest': 'empty',
                    'Sec-Fetch-Mode': 'cors',
                    'Sec-Fetch-Site': 'same-origin'
                }
            });
            if (!response.ok) {
                throw new Error(`HTTP ${response.status}`);
            }
            """;
    // SpoofChecker для обробки гомогліфів
    private static final SpoofChecker SPOOF_CHECKER;
    private boolean localRead;
    static {
        SpoofChecker.Builder builder = new SpoofChecker.Builder();
        builder.setChecks(SpoofChecker.CONFUSABLE);
        SPOOF_CHECKER = builder.build();
        logger.debug("SpoofChecker initialized for confusables");
    }
    public GetPrescript(Properties p, String i, String mt) throws IOException {
        this.localRead = true;
        this.prop = p;
        this.debug = this.prop.getProperty("debug", "false").equalsIgnoreCase("true");
        this.id = i;
        this.mimeType = mt;
        this.urlPrescript = this.prop.getProperty(
                "urlPrescript",
                "https://cip.gov.ua/services/cm/api/attachment/download?id="
        ).trim().concat(this.id);
        String storePrescriptToStr = p.getProperty("store_prescript_to", "./Prescript").trim();
        this.storePrescriptTo = Paths.get(storePrescriptToStr).normalize();
        try {
            Files.createDirectories(this.storePrescriptTo);
            logger.debug("Ensured directory exists: {}", this.storePrescriptTo);
        } catch (IOException e) {
            logger.error("Failed to create directory {}: {}", this.storePrescriptTo, e.getMessage(), e);
            throw new RuntimeException("Cannot create directory: " + this.storePrescriptTo, e);
        }
        this.userAgent = this.prop.getProperty(
                "userAgent",
                "Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/129.0.0.0 Safari/537.36"
        ).trim();
        this.secChUa = this.prop.getProperty(
                "secChUa",
                "\"Chromium\";v=\"129\", \"Not:A-Brand\";v=\"24\", \"Google Chrome\";v=\"129\""
        ).trim();
        String subdomains = p.getProperty("SERVICE_SUBDOMAINS",
                "www,ftp,mail,api,blog,shop,login,admin,web,secure,m,mobile,app,dev,test,m");
        this.serviceSubdomains = Arrays.stream(subdomains.split(","))
                .map(String::trim)
                .filter(s -> !s.isEmpty())
                .filter(s -> {
                    boolean valid = s.matches("[a-zA-Z0-9-]+");
                    if (!valid && debug) {
                        logger.debug("Invalid subdomain skipped: {}", s);
                    }
                    return valid;
                })
                .toArray(String[]::new);
        if (serviceSubdomains.length == 0) {
            logger.warn("No valid service subdomains defined in SERVICE_SUBDOMAINS");
        }
        this.maxFileSizeBytes = Long.parseLong(
                this.prop.getProperty("max_file_size_bytes", String.valueOf(MAX_FILE_SIZE_BYTES_DEFAULT))
        );
        logger.debug("Max file size set to {} bytes", this.maxFileSizeBytes);
    }
    public GetPrescript getPrescriptFrom() {
        try {
            if (isExists(getFileName())) {
                if (!mimeType.equalsIgnoreCase("text/plain")) {
                    logger.debug("Skipping read for non-text/plain file ID {}: {}", id, getFileName());
                    return this;
                }
                logger.info("Reading existing prescript file for ID {}: {}", id, getFileName());
                this.bodyPrescript = readLocalPrescript();
            } else if (mimeType.equalsIgnoreCase("text/plain")) {
                logger.info("Fetching prescript for ID {} from server", id);
                this.bodyPrescript = fetchPrescriptWithRetry(this.prop, 5);
                this.localRead = false;
            } else {
                logger.debug("Skipping fetch for non-text/plain file ID {}: no local file", id);
            }
        } catch (IOException ex) {
            logger.warn("Failed getPrescriptFrom: {}", id);
            this.localRead = false;
            throw new RuntimeException("Failed to get prescript for ID " + id, ex);
        }
        return this;
    }
    private String executeAjaxRequest(boolean returnAsDataUrl) throws
            IOException {
        try (Playwright playwright = Playwright.create();
             Browser browser = playwright.chromium().launch(new BrowserType.LaunchOptions()
                     .setHeadless(true)
                     .setChannel("chrome"));
             BrowserContext context = browser.newContext(new Browser.NewContextOptions()
                     .setUserAgent(this.userAgent)
                     .setLocale("uk-UA")
                     .setExtraHTTPHeaders(Map.of(
                             "Accept", "text/plain, */*",
                             "Accept-Language", "uk,en-US;q=0.9,en;q=0.8,ru;q=0.7",
                             "Sec-Ch-Ua", this.secChUa,
                             "Sec-Fetch-Dest", "empty",
                             "Sec-Fetch-Mode", "cors",
                             "Sec-Fetch-Site", "same-origin"
                     ))); Page page = context.newPage()) {
            // Блокуємо запити до Google Analytics і Google Tag Manager
            page.route("**/*google-analytics.com/**", route -> {
                String url = route.request().url();
                logger.debug("Blocked Google Analytics request: {}", url);
                route.abort();
            });
            page.route("**/*googletagmanager.com/**", route -> {
                String url = route.request().url();
                logger.debug("Blocked Google Tag Manager request: {}", url);
                route.abort();
            });
            // Блокуємо статичні ресурси (зображення, шрифти, стилі)
            page.route("**/*.{jpg,jpeg,png,svg,woff,woff2,ttf,css,gif,ico}", route -> {
                String url = route.request().url();
                logger.debug("Blocked static resource: {}", url);
                route.abort();
            });
            // Логування запитів і відповідей у дебаг-режимі
            if (this.debug) {
                page.onRequest(request -> logger.debug("Playwright request: {} {}", request.method(), request.url()));
                page.onResponse(response -> logger.debug("Playwright response: {} {} {}",
                        response.status(), response.request().method(), response.url()));
            }
            // Витягуємо базовий URL із urlPrescript
            String baseUrl;
            try {
                URI uri = new URI(urlPrescript);
                String scheme = uri.getScheme();
                String host = uri.getHost();
                int port = uri.getPort();
                baseUrl = scheme + "://" + host + (port != -1 ? ":" + port : "") + "/";
            } catch (URISyntaxException e) {
                logger.warn("Failed to parse base URL from {}, falling back to default: {}", urlPrescript, e.getMessage());
                baseUrl = "https://cip.gov.ua/";
            }
            // Ініціалізація сесії
            logger.debug("Navigating to base URL: {}", baseUrl);
            //page.navigate(baseUrl);
            //page.waitForLoadState();
            page.navigate(baseUrl, new Page.NavigateOptions().setTimeout(30000));  // 30с тайм-аут
            page.waitForLoadState(LoadState.LOAD, new Page.WaitForLoadStateOptions().setTimeout(30000));  // Тайм-аут для wait
            /*
            // Формуємо JavaScript-скрипт
            String script = returnAsDataUrl
                    ? """
                    async () => {
                        %s
                        const blob = await response.blob();
                        return new Promise(resolve => {
                            const reader = new FileReader();
                            reader.onload = () => resolve(reader.result);
                            reader.readAsDataURL(blob);
                        });
                    }
                    """.formatted(FETCH_SCRIPT_TEMPLATE.formatted(this.urlPrescript, this.secChUa))
                    : """
                    async () => {
                        %s
                        return await response.text();
                    }
                    """.formatted(FETCH_SCRIPT_TEMPLATE.formatted(this.urlPrescript, this.secChUa));
            return (String) page.evaluate(script);
             */
            if (returnAsDataUrl) {
                logger.debug("executeAjaxRequest: {} is binary: {}", urlPrescript, returnAsDataUrl);
                // Для бінарних файлів (PDF) використовуємо прямий запит
                APIResponse response = page.request().get(urlPrescript);
                if (!response.ok()) {
                    logger.warn("HTTP  {}: {}", response.status(), response.statusText());
                    throw new IOException("HTTP " + response.status() + ": " + response.statusText());
                }
                byte[] content = response.body();
                if (content.length > maxFileSizeBytes) {
                    logger.warn("File too large: {}  bytes, max allowed: {}", content.length, maxFileSizeBytes);
                    throw new IOException("File too large: " + content.length + " bytes, max allowed: " + maxFileSizeBytes);
                } else {
                    logger.debug("File size: {}  bytes", content.length);
                }
                return "data:application/octet-stream;base64," + java.util.Base64.getEncoder().encodeToString(content);
            } else {
                logger.debug("executeAjaxRequest: {} is text: {}", urlPrescript, returnAsDataUrl);
                // Для текстових файлів використовуємо JavaScript
                String script = """
                    async () => {
                        const response = await fetch('%s', {
                            method: 'GET',
                            headers: {
                                'Accept': 'text/plain, */*',
                                'Sec-Ch-Ua': '%s',
                                'Sec-Fetch-Dest': 'empty',
                                'Sec-Fetch-Mode': 'cors',
                                'Sec-Fetch-Site': 'same-origin'
                            }
                        });
                        if (!response.ok) {
                            throw new Error(`HTTP ${response.status}`);
                        }
                        return await response.text();
                    }
                    """.formatted(urlPrescript, secChUa);
                return (String) page.evaluate(script);
            }
        }
    }
    private String readLocalPrescript() throws IOException {
        File file = new File(getFileName());
        return Files.readString(file.toPath(), StandardCharsets.UTF_8);
    }
    private String fetchPrescriptWithRetry(Properties p, int maxRetries) throws
            IOException {
        for (int attempt = 1; attempt <= maxRetries; attempt++) {
            try {
                String result = executeAjaxRequest(false);
                logger.info("Successfully fetched prescript ID {} on attempt {}", this.id, attempt);
                return result;
            } catch (Exception e) {
                logger.warn("Attempt {} failed for ID {}: {}", attempt, this.id, e.getMessage());
                if (attempt == maxRetries) {
                    logger.error("Failed to fetch prescript ID {} after {} attempts: {}", this.id, maxRetries, e.getMessage());
                    try (FileWriter fw = new FileWriter("failed_ids.txt", true)) {
                        fw.write("ID: " + this.id + ", Error: " + e.getMessage() + "\n");
                    }
                    throw new IOException("Failed to fetch prescript after " + maxRetries + " attempts: " + e.getMessage(), e);
                }
                try {
                    Thread.sleep(1000 + (long) (Math.random() * 5000));
                } catch (InterruptedException ie) {
                    Thread.currentThread().interrupt();
                }
            }
        }
        throw new IOException("Failed to fetch prescript: no attempts succeeded");
    }
    public String[] getBodyPrescript() {
        if (bodyPrescript == null || bodyPrescript.length() > 10_000_000) {
            logger.warn("Prescript ID {} is too large ({} bytes) or null, skipping", id, bodyPrescript != null ? bodyPrescript.length() : 0);
            return new String[0];
        }
        DomainValidator domainValidator = DomainValidator.getInstance(true);
        InetAddressValidator ipValidator = InetAddressValidator.getInstance();
        Set<String> validDomains = new HashSet<>();
        for (String s : this.bodyPrescript.split("\n")) {
            validDomains.addAll(DomainValidatorUtil.validateDomain(
                    s, serviceSubdomains, null, domainValidator, ipValidator, SPOOF_CHECKER, logger,
                    false, null, null));
        }
        return validDomains.toArray(String[]::new);
    }
    public GetPrescript storePrescriptTo() {
        if (isExists(getFileName())) {
            logger.debug("Skipping store for ID {}: file already exists or origFileName not set", id);
            return this;
        }
        // Перевірка прав доступу
        File storeDir = storePrescriptTo.toFile();
        if (!storeDir.canWrite()) {
            logger.error("Directory {} is not writable for ID {}", storePrescriptTo, id);
            try (FileWriter fw = new FileWriter("failed_ids.txt", true)) {
                fw.write("ID: " + id + ", Error: Directory not writable: " + storePrescriptTo + "\n");
            } catch (IOException ex) {
                logger.error("Can't write failed_ids.txt: {}", ex.toString());
            }
            return this;
        }
        // Перевірка вільного місця
        long freeSpace = storeDir.getFreeSpace();
        if (logger.isDebugEnabled()) {
            logger.debug("Free space in {}: {} bytes", storePrescriptTo, freeSpace);
        }
        if (freeSpace < MAX_FILE_SIZE_BYTES_DEFAULT * 2) {
            logger.error("Not enough disk space for ID {}: {} bytes available", id, freeSpace);
            try (FileWriter fw = new FileWriter("failed_ids.txt", true)) {
                fw.write("ID: " + id + ", Error: Not enough disk space (" + freeSpace + " bytes available)\n");
            } catch (IOException ex) {
                logger.error("Can't write failed_ids.txt: {}", ex.toString());
            }
            return this;
        }
        if (this.mkDir()) {
            for (int attempt = 1; attempt <= 3; attempt++) {
                try {
                    String dataUrl = executeAjaxRequest(true);
                    logger.debug("dataUrl length: {}", dataUrl.length());
                    byte[] fileContent = java.util.Base64.getDecoder().decode(dataUrl.split(",")[1]);
                    logger.debug("fileContent length: {}", fileContent.length);
                    if (fileContent.length > maxFileSizeBytes) {
                        logger.debug("File ID {} is too large: {} bytes, max allowed: {} bytes",
                                id, fileContent.length, maxFileSizeBytes);
                        try (FileWriter fw = new FileWriter("failed_ids.txt", true)) {
                            fw.write("ID: " + id + ", Error: File too large (" + fileContent.length + " bytes, max " + maxFileSizeBytes + " bytes)\n");
                        }
                        return this;
                    }
                    try (FileOutputStream fos = new FileOutputStream(getFileName())) {
                        fos.write(fileContent);
                    }
                    logger.info("Stored prescript {} on attempt {}", this.id, attempt);
                    return this;
                } catch (IOException e) {
                    logger.warn("Store attempt {} failed for ID {}: {}", attempt, this.id, e.getMessage());
                    if (attempt == 3) {
                        logger.error("Failed to store prescript {} after 3 attempts", this.id);
                        try (FileWriter fw = new FileWriter("failed_ids.txt", true)) {
                            fw.write("ID: " + this.id + ", Error: Failed to store after 3 attempts\n");
                        } catch (IOException ex) {
                            logger.warn("Failed to write to failed_ids.txt for ID {}: {}", this.id, ex.getMessage());
                        }
                    }
                    try {
                        Thread.sleep(1000 + (long) (Math.random() * 1000));
                    } catch (InterruptedException ie) {
                        Thread.currentThread().interrupt();
                    }
                }
            }
        } else {
            logger.error("Failed to create directory for ID {}: {}", id, storePrescriptTo);
        }
        return this;
    }
    protected boolean mkDir() {
        try {
            Files.createDirectories(storePrescriptTo);
            return true;
        } catch (IOException e) {
            logger.warn("Failed to create directory {}: {}", storePrescriptTo, e.getMessage());
            return false;
        }
    }
    protected boolean isExists(String fn) {
        File f = new File(fn);
        logger.debug("isExists ⮕ ({}, {})", f.exists(), f.canRead());
        return f.exists() && f.canRead();
    }
    public GetPrescript setOrigFileName(String fileName) {
        if (fileName == null) {
            this.origFileName = null;
            return this;
        }
        String ext = "";
        String cleanedName = fileName;
        // Перевіряємо довжину в байтах UTF-8
        if (cleanedName.getBytes(StandardCharsets.UTF_8).length > 250) {
            // Витягуємо розширення
            int lastDot = fileName.lastIndexOf('.');
            String namePart = lastDot > 0 ? fileName.substring(0, lastDot) : fileName;
            ext = lastDot > 0 ? fileName.substring(lastDot) : "";
            // Обрізаємо основну частину до 240 байт (залишаємо місце для розширення)
            if (namePart.getBytes(StandardCharsets.UTF_8).length > 240) {
                namePart = trimToUtf8Bytes(namePart, 240);
                // Обрізати до останнього пробілу
                int lastSpace = namePart.lastIndexOf(' ');
                if (lastSpace > 0) {
                    namePart = namePart.substring(0, lastSpace);
                }
            }
            // Формуємо нове ім’я
            cleanedName = namePart + (ext.isEmpty() ? "" : "...") + ext;
        }
        if (cleanedName.matches(".*[\\/:*?\"<>|].*")) {
            logger.warn("Invalid characters in filename for ID {}: {} : {}", id, fileName, cleanedName);
            cleanedName = id + "_prescript" + (ext.isEmpty() ? ".unknown" : ext);
        }
        if (cleanedName.getBytes(StandardCharsets.UTF_8).length > 255) {
            logger.warn("Cleaned filename still too long for ID {}: {}, trimming further", id, cleanedName);
            cleanedName = trimToUtf8Bytes(cleanedName, 255);
        }
        this.origFileName = cleanedName;
        logger.debug("Cleaned origFileName to {} for ID {}", this.origFileName, id);
        return this;
    }
    public static String trimToUtf8Bytes(String input, int maxBytes) {
        if (input == null) {
            return null;
        }
        byte[] utf8 = input.getBytes(StandardCharsets.UTF_8);
        if (utf8.length <= maxBytes) {
            return input;
        }
        int byteCount = 0;
        int endIndex = 0;
        for (int i = 0; i < input.length(); i++) {
            int codePoint = input.codePointAt(i);
            String ch = new String(Character.toChars(codePoint));
            int chByteLen = ch.getBytes(StandardCharsets.UTF_8).length;
            if (byteCount + chByteLen > maxBytes) {
                break;
            }
            byteCount += chByteLen;
            endIndex = i + 1;
            if (Character.isHighSurrogate(input.charAt(i))) {
                i++; // Пропускаємо низьку сурогатну пару
            }
        }
        if (logger.isDebugEnabled()) {
            logger.debug("Trimmed inString \"{}\" from {} to {} bytes ({} to {} chars)", input, utf8.length, byteCount, input.length(), endIndex);
        }
        return input.substring(0, endIndex);
    }
    public String getOrigFileName() {
        return this.origFileName;
    }
    public String getFileName() {
        Path filePath = storePrescriptTo.resolve(this.id + "~" + (origFileName != null ? origFileName : this.id + "_prescript.txt"));
        String fileName = filePath.toString();
        logger.debug("getFileName ⮕ {} ⮕ {}", fileName, isExists(fileName));
        return fileName;
    }
    public boolean isLocalRead() {
        return this.localRead;
    }
}
/*
 * File:  src/main/java/net/ukrcom/cip_gov_ua_getter/AggressorServicesParser.java
 */
/*
 * Copyright 2025 olden
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package net.ukrcom.cip_gov_ua_getter;
import org.jsoup.Jsoup;
import org.jsoup.nodes.Document;
import org.jsoup.nodes.Element;
import java.io.IOException;
import java.nio.file.Path;
import java.util.Properties;
import java.util.Set;
import java.util.TreeSet;
/**
 * Парсер для отримання списку доменів із сервісів держави-агресора.
 *
 * @author olden
 */
public class AggressorServicesParser extends AbstractPDFParser {
    private final String primaryPdfName;
    public AggressorServicesParser(Properties properties, boolean debug) {
        super(properties, debug);
        this.sourceDomain = properties.getProperty("AggressorServices_SOURCE_DOMAIN", "webportal.nrada.gov.ua");
        this.primaryPdfName = properties.getProperty("AggressorServices_PRIMARY_PDF_NAME", "Perelik.#450.2023.07.06.pdf");
    }
    @Override
    public Set<BlockedDomain> parse() {
        Set<BlockedDomain> domains = new TreeSet<>(new BlockedDomainComparator());
        String targetUrl = properties.getProperty("urlAggressorServices");
        if (targetUrl == null || targetUrl.isEmpty()) {
            logger.info("urlAggressorServices not specified in properties, skipping aggressor services parsing");
            return domains;
        }
        try {
            disableSSLCertificateVerification();
            String pdfUrl = findPdfUrl(targetUrl);
            if (pdfUrl != null) {
                Path primaryPdfPath = manualDir.resolve(primaryPdfName);
                downloadPdf(pdfUrl, primaryPdfPath.toString());
                logger.info("Successfully downloaded PDF to: {}", primaryPdfPath);
                domains.addAll(extractDomainsFromPDF(primaryPdfPath.toString()));
                if (debug) {
                    logger.debug("Extracted {} domains from aggressor services PDF", domains.size());
                }
            } else {
                logger.warn("Could not find PDF link on page: {}", targetUrl);
            }
        } catch (Exception e) {
            logger.error("Error parsing aggressor services: {}", e.getMessage(), e);
        }
        return domains;
    }
    private String findPdfUrl(String url) throws IOException {
        Document doc = Jsoup.connect(url).get();
        Element pdfLink = doc.select("a[href$=.pdf]").first();
        if (pdfLink != null) {
            String pdfUrl = pdfLink.attr("href");
            if (!pdfUrl.startsWith("http")) {
                pdfUrl = "https://" + sourceDomain + pdfUrl;
            }
            return pdfUrl;
        }
        return null;
    }
}
/*
 * File:  src/main/java/net/ukrcom/cip_gov_ua_getter/CGUGetter.java
 */
/*
 * Copyright 2025 olden
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package net.ukrcom.cip_gov_ua_getter;
import com.microsoft.playwright.*;
import java.util.Map;
import java.util.Properties;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
/**
 * Клас реалізує зчитування розпоряджень щодо блокування доменів через API.
 *
 * @author olden
 */
public class CGUGetter {
    private static final Logger logger = LoggerFactory.getLogger(CGUGetter.class);
    protected final String urlArticles;
    protected String jsonBodyArticles;
    private final String userAgent;
    private final String secChUa;
    private final Properties prop;
    private final boolean debug;
    /**
     * Конструктор класа. Підключаємося до API і зчитуємо отримані дані,
     * формуючи з них правильний JSON, для подальшого аналізу.
     *
     * @param p - об'єкт властивостей.
     */
    public CGUGetter(Properties p) {
        this.prop = p;
        this.debug = this.prop.getProperty("debug", "false").equalsIgnoreCase("true");
        this.urlArticles = p.getProperty(
                "urlArticles",
                "https://cip.gov.ua/services/cm/api/articles?page=0&size=1000&tagId=60751"
        ).trim();
        this.userAgent = p.getProperty(
                "userAgent",
                "Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/129.0.0.0 Safari/537.36"
        ).trim();
        this.secChUa = p.getProperty(
                "secChUa",
                "\"Chromium\";v=\"129\", \"Not:A-Brand\";v=\"24\", \"Google Chrome\";v=\"129\""
        ).trim();
        try (Playwright playwright = Playwright.create(); Browser browser = playwright.chromium().launch(new BrowserType.LaunchOptions().setHeadless(true).setChannel("chrome"))) {
            BrowserContext context = browser.newContext(new Browser.NewContextOptions()
                    .setUserAgent(this.userAgent)
                    .setLocale("uk-UA")
                    .setExtraHTTPHeaders(Map.of(
                            "Accept", "application/json, text/plain, */*",
                            "Accept-Language", "uk,en-US;q=0.9,en;q=0.8,ru;q=0.7",
                            "Sec-Ch-Ua", this.secChUa,
                            "Sec-Fetch-Dest", "empty",
                            "Sec-Fetch-Mode", "cors",
                            "Sec-Fetch-Site", "same-origin"
                    )));
            Page page = context.newPage();
            // Блокуємо запити до Google Analytics і Google Tag Manager
            page.route("**/*google-analytics.com/**", route -> {
                String url = route.request().url();
                logger.debug("Blocked Google Analytics request: {}", url);
                route.abort();
            });
            page.route("**/*googletagmanager.com/**", route -> {
                String url = route.request().url();
                logger.debug("Blocked Google Tag Manager request: {}", url);
                route.abort();
            });
            // Блокуємо статичні ресурси (зображення, шрифти, стилі)
            page.route("**/*.{jpg,jpeg,png,svg,woff,woff2,ttf,css,gif,ico}", route -> {
                String url = route.request().url();
                logger.debug("Blocked static resource: {}", url);
                route.abort();
            });
            // Логування запитів і відповідей у дебаг-режимі
            if (this.debug) {
                page.onRequest(request -> logger.debug("Playwright request: {} {}", request.method(), request.url()));
                page.onResponse(response -> logger.debug("Playwright response: {} {} {}",
                        response.status(), response.request().method(), response.url()));
            }
            Response response = page.waitForResponse(
                    r -> r.url().contains("articles"),
                    () -> page.navigate(this.urlArticles)
            );
            String rawResponse = response.text();
            this.jsonBodyArticles = "{ \"posts\": " + rawResponse + " }";
            logger.info("Successfully fetched articles for URL: {}", this.urlArticles);
        } catch (Exception e) {
            logger.error("Failed to fetch articles: {}", e.getMessage(), e);
            throw new RuntimeException("Failed to fetch articles: " + e.getMessage(), e);
        }
    }
    /**
     * Повертає зчитаний JSON, для подальшого аналізу.
     *
     * @return
     */
    public String getJsonBody() {
        return this.jsonBodyArticles;
    }
}
/*
 * File:  src/main/java/net/ukrcom/cip_gov_ua_getter/BlockedObjects.java
 */
/*
 * Click nbfs://nbhost/SystemFileSystem/Templates/Licenses/license-default.txt to change this license
 * Click nbfs://nbhost/SystemFileSystem/Templates/Classes/Class.java to edit this template
 */
package net.ukrcom.cip_gov_ua_getter;
import java.io.File;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.OutputStreamWriter;
import java.io.PrintWriter;
import java.net.IDN;
import java.nio.charset.StandardCharsets;
import java.nio.file.Files;
import java.nio.file.Paths;
import java.util.Properties;
import java.util.TreeSet;
import org.apache.commons.validator.routines.DomainValidator;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
/**
 * Клас формує перелік доменів, що підлягають блокуванню.
 *
 * @author olden
 */
public class BlockedObjects {
    private static final Logger logger = LoggerFactory.getLogger(BlockedObjects.class);
    protected String currentPath; // Current dir
    protected String currentDir;  // Current dir using System
    private final String[] blockedNames;
    private final String blockedResultName;
    private final TreeSet<BlockedDomain> blockedDomains;
    /**
     * Конструктор класа.
     *
     * @param p - об'єкт властивостей
     */
    public BlockedObjects(Properties p) {
        try {
            this.currentPath = new File(".").getCanonicalPath();
            this.currentDir = System.getProperty("user.dir");
        } catch (IOException ex) {
            logger.error("Failed to initialize paths: {}", ex.getMessage(), ex);
        }
        this.blockedNames = p.getProperty("blocked", "blocked.txt").split(";");
        this.blockedResultName = p.getProperty("blocked_result", "blocked.result.txt");
        this.blockedDomains = new TreeSet<>(new BlockedDomainComparator());
    }
    /**
     * Зчитує перелік доменів із файлів, указаних у властивості blocked. Додає
     * їх до TreeSet із датою за замовчуванням (початок епохи).
     *
     * @return цей об'єкт для ланцюгових викликів
     * @throws IOException у разі помилок читання файлів
     */
    public BlockedObjects getBlockedDomainNames() throws IOException {
        /*
        for (String blockedName : blockedNames) {
            File blockedFile = new File(blockedName.trim());
            if (blockedFile.exists() && blockedFile.isFile() && blockedFile.canRead()) {
                logger.info("Reading blocked domains from {}", blockedName);
                try (BufferedReader bufferedReader = new BufferedReader(
                        new InputStreamReader(new FileInputStream(blockedFile), "UTF-8"))) {
                    String blockedDomainName;
                    while ((blockedDomainName = bufferedReader.readLine()) != null) {
                        if (!blockedDomainName.trim().isEmpty()) {
                            this.addBlockedDomainName(new BlockedDomain(blockedDomainName.trim()));
                        }
                    }
                }
            } else {
                logger.warn("File {} does not exist or is not readable", blockedName);
            }
        }
        return this;
         */
        for (String blockedName : blockedNames) {
            File blockedFile = new File(blockedName.trim());
            if (blockedFile.exists() && blockedFile.isFile() && blockedFile.canRead()) {
                logger.info("Reading blocked domains from {}", blockedName);
                DomainValidator domainValidator = DomainValidator.getInstance(true);
                Files.lines(Paths.get(blockedFile.getPath()), StandardCharsets.UTF_8)
                        .map(String::trim)
                        .filter(line -> !line.isEmpty())
                        .forEach(line -> {
                            if (line.length() > 255) {
                                logger.warn("Skipping domain from file due to invalid length: {}", line);
                                return;
                            }
                            try {
                                String idnDomain = IDN.toASCII(line, IDN.ALLOW_UNASSIGNED);
                                if (idnDomain.length() > 255) {
                                    logger.warn("Skipping domain after IDN conversion due to length: {}", idnDomain);
                                    return;
                                }
                                if (domainValidator.isValid(idnDomain)) {
                                    this.addBlockedDomainName(new BlockedDomain(idnDomain));
                                    logger.info("Added domain from file: {}", idnDomain);
                                } else {
                                    logger.warn("Invalid domain in file: {}", line);
                                }
                            } catch (IllegalArgumentException e) {
                                logger.warn("Failed to process domain from file: {} ({})", line, e.getMessage());
                            }
                        });
            } else {
                logger.warn("File {} does not exist or is not readable", blockedName);
            }
        }
        return this;
    }
    /**
     * Додає домен до переліку.
     *
     * @param bdn об'єкт BlockedDomain
     * @return true, якщо домен додано успішно
     */
    public boolean addBlockedDomainName(BlockedDomain bdn) {
        return this.blockedDomains.add(bdn);
    }
    /**
     * Зберігає перелік доменів у вихідний файл, указаний у blocked_result.
     * Включає лише домени зі статусом isBlocked = true.
     *
     * @return цей об'єкт для ланцюгових викликів
     * @throws IOException у разі помилок запису
     */
    public BlockedObjects storeState() throws IOException {
        TreeSet<String> blockedDomainsResultList = new TreeSet<>();
        for (BlockedDomain bd : this.blockedDomains) {
            if (bd.getIsBlocked()) {
                blockedDomainsResultList.add(bd.getDomainName());
            } else {
                blockedDomainsResultList.remove(bd.getDomainName());
            }
        }
        try (PrintWriter pw = new PrintWriter(
                new OutputStreamWriter(
                        new FileOutputStream(this.blockedResultName.trim()),
                        "UTF-8"))) {
            logger.info("Writing blocked domains to {}", this.blockedResultName);
            for (String s : blockedDomainsResultList) {
                pw.println(s);
            }
            pw.flush();
        }
        logger.info("Successfully stored blocked domains to {}", this.blockedResultName);
        return this;
    }
}
/*
 * File:  src/main/resources/logback.xml
 */
<?xml version="1.0" encoding="UTF-8"?>
<configuration>
    <appender name="CONSOLE" class="ch.qos.logback.core.ConsoleAppender">
        <encoder>
            <pattern>%d{yyyy-MM-dd HH:mm:ss} %-5level %logger{36} - %msg%n</pattern>
        </encoder>
    </appender>
    <appender name="FILE" class="ch.qos.logback.core.rolling.RollingFileAppender">
        <file>logs/cip_gov_ua_getter.log</file>
        <rollingPolicy class="ch.qos.logback.core.rolling.TimeBasedRollingPolicy">
            <fileNamePattern>logs/cip_gov_ua_getter.%d{yyyy-MM-dd}.log</fileNamePattern>
            <maxHistory>30</maxHistory>
        </rollingPolicy>
        <encoder>
            <pattern>%d{yyyy-MM-dd HH:mm:ss} %-5level %logger{36} - %msg%n</pattern>
        </encoder>
    </appender>
    <!-- Логер для твого пакету -->
    <logger name="net.ukrcom.cip_gov_ua_getter" level="INFO" additivity="false">
        <appender-ref ref="CONSOLE"/>
        <appender-ref ref="FILE" />
    </logger>
    <!-- Логери для PDFBox і FontBox -->
    <logger name="org.apache.pdfbox" level="WARN" additivity="false">
        <appender-ref ref="CONSOLE"/>
        <appender-ref ref="FILE" />
    </logger>
    <logger name="org.apache.fontbox" level="WARN" additivity="false">
        <appender-ref ref="CONSOLE"/>
        <appender-ref ref="FILE" />
    </logger>
    <!-- Кореневий логер -->
    <root level="INFO">
        <appender-ref ref="CONSOLE" />
        <appender-ref ref="FILE" />
    </root>
</configuration>
/*
 * File:  ./pom.xml
 */
<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
    <modelVersion>4.0.0</modelVersion>
    <groupId>net.ukrcom</groupId>
    <artifactId>cip_gov_ua_getter</artifactId>
    <version>3.1.1</version>
    <packaging>jar</packaging>
    <properties>
        <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>
        <maven.compiler.release>21</maven.compiler.release>
    </properties>
    <dependencies>
        <dependency>
            <groupId>com.microsoft.playwright</groupId>
            <artifactId>playwright</artifactId>
            <version>1.54.0</version>
            <exclusions>
                <exclusion>
                    <groupId>com.ibm.icu</groupId>
                    <artifactId>icu4j</artifactId>
                </exclusion>
            </exclusions>
        </dependency>
        <dependency>
            <groupId>com.ibm.icu</groupId>
            <artifactId>icu4j</artifactId>
            <version>77.1</version>
        </dependency>
        <dependency>
            <groupId>commons-validator</groupId>
            <artifactId>commons-validator</artifactId>
            <version>1.10.0</version>
        </dependency>
        <dependency>
            <groupId>ch.qos.logback</groupId>
            <artifactId>logback-classic</artifactId>
            <version>1.5.18</version>
        </dependency>
        <dependency>
            <groupId>org.json</groupId>
            <artifactId>json</artifactId>
            <version>20250517</version>
        </dependency>
        <dependency>
            <groupId>org.apache.pdfbox</groupId>
            <artifactId>pdfbox</artifactId>
            <version>3.0.5</version>
        </dependency>
        <dependency>
            <groupId>org.jsoup</groupId>
            <artifactId>jsoup</artifactId>
            <version>1.21.1</version>
        </dependency>
    </dependencies>
    <build>
        <plugins>
            <plugin>
                <groupId>org.apache.maven.plugins</groupId>
                <artifactId>maven-shade-plugin</artifactId>
                <version>3.6.0</version>
                <executions>
                    <execution>
                        <phase>package</phase>
                        <goals>
                            <goal>shade</goal>
                        </goals>
                        <configuration>
                            <outputFile>
                                ${project.build.directory}/${project.artifactId}-${project.version}-all.jar
                            </outputFile>
                            <transformers>
                                <transformer implementation="org.apache.maven.plugins.shade.resource.ManifestResourceTransformer">
                                    <mainClass>net.ukrcom.cip_gov_ua_getter.Cip_gov_ua_getter</mainClass>
                                    <manifestEntries>
                                        <Implementation-Version>${project.version}</Implementation-Version>
                                    </manifestEntries>
                                </transformer>
                            </transformers>                        
                        </configuration>
                    </execution>
                </executions>
            </plugin>
        </plugins>
    </build>
    <licenses>
        <license>
            <name>Apache License, Version 2.0</name>
            <url>http://www.apache.org/licenses/LICENSE-2.0</url>
            <distribution>repo</distribution>
        </license>
    </licenses>
</project>
/*
 * File:  ./nb-configuration.xml
 */
<?xml version="1.0" encoding="UTF-8"?>
<project-shared-configuration>
    <!--
This file contains additional configuration written by modules in the NetBeans IDE.
The configuration is intended to be shared among all the users of project and
therefore it is assumed to be part of version control checkout.
Without this configuration present, some functionality in the IDE may be limited or fail altogether.
-->
    <properties xmlns="http://www.netbeans.org/ns/maven-properties-data/1">
        <!--
Properties that influence various parts of the IDE, especially code formatting and the like. 
You can copy and paste the single properties, into the pom.xml file and the IDE will pick them up.
That way multiple projects can share the same settings (useful for formatting rules for example).
Any value defined here will override the pom.xml file value but is only applicable to the current project.
-->
        <org-netbeans-modules-javascript2-requirejs.enabled>true</org-netbeans-modules-javascript2-requirejs.enabled>
    </properties>
</project-shared-configuration>
/*
 * File:  ./README.md
 */
# cip.gov.ua-getter
## Що ми тут робимо?
Читаємо та аналізуємо розпорядження НЦУ, адже є розпорядження НКРЗІ, яке зобов’язує провайдерів щоденно моніторити та виконувати розпорядження НЦУ.
На виході формуємо з текстових даних список доменів, які блокуються на рівні DNS. Утиліта завантажує розпорядження через API, обробляє вкладення (TXT, PDF), валідує домени та формує `blocked.result.txt` із актуальними доменами для блокування.
Починаючи з версії 3.0, утиліта також парсить перелік сервісів держави-агресора з `webportal.nrada.gov.ua`, додаючи відповідні домени до `blocked.result.txt`.
## Чого хотілося б?
Хотілося б, щоб НЦУ надало нормальний API для:
- Актуального списку доменів для блокування на рівні DNS.
- Списку AS для блокування на рівні BGP.
- Списку IPv4 та IPv6 для блокування на рівні L3.
Поки що кожен провайдер змушений вигадувати свій велосипед, а НКРЗІ лише каже: "Є розпорядження — виконуйте!" Як? Ну, це вже ваші проблеми… 😅
## Про проект
`cip_gov_ua_getter` — консольна утиліта для збору розпоряджень про блокування доменів із сайту cip.gov.ua. Вона:
- Завантажує розпорядження через API (`articles` та `attachment/download`).
- Кешує вкладення локально в папці `PRESCRIPT`.
- Валідує домени, обробляє гомогліфи та пропускає IP-адреси.
- Формує список заблокованих доменів у `blocked.result.txt`.
- Підтримує дебаг-режим для детальних логів.
- Парсить перелік сервісів держави-агресора з `webportal.nrada.gov.ua` (з версії 3.0).
### Можливості
- **Парсинг сервісів держави-агресора**: Витягує домени з PDF на `webportal.nrada.gov.ua` і додає їх до `blocked.result.txt`.
- **Оптимізація швидкості**: ~6 секунд для запусків із локальним кешем, ~30-35 хвилин для першого "чистого" запуску.
- **Продуктивність**: ~6 секунд для запусків із локальним кешем, ~30-35 хвилин для першого запуску (залежить від мережі та кількості вкладень). Для прискорення увімкніть кешування (локальна папка `PRESCRIPT`) і стабільне підключення до мережі.
- **Блокування непотрібних ресурсів**: Ігноруються `.jpg`, `.jpeg`, `.png`, `.svg`, `.woff2`, `.css`, Google Analytics і Google Tag Manager для швидшого завантаження.
- **Гнучке логування**: Режим `-d` для дебаг-логів, чисті логи на `INFO` за замовчуванням.
- **Валідатор доменів**: Перевірка через `commons-validator`, обробка гомогліфів із `icu4j`.
- **Кешування**: Локальні файли зменшують кількість запитів до API.
- **Конфігурація**: Налаштування через `cip.gov.ua.properties` (шляхи, User-Agent, вхідні/вихідні файли, URL сервісів агресора).
## Встановлення
1. **Вимоги**:
   - Java 21+.
   - Maven 3.6+.
   - ~2 ГБ RAM (для Playwright).
   - Debian 11+ або інша ОС із підтримкою Chromium.
2. **Клонування репозиторію**:
   ```bash
   git clone https://github.com/oldengremlin/cip_gov_ua_getter.git
   cd cip_gov_ua_getter
   ```
3. **Встановлення залежностей**:
   ```bash
   mvn clean install
   ```
4. **Створення конфігурації**: Створіть файл `cip.gov.ua.properties` у корені проекту. Приклад:
   ```properties
   urlArticles=https://cip.gov.ua/services/cm/api/articles?page=0&size=1000&tagId=60751
   urlPrescript=https://cip.gov.ua/services/cm/api/attachment/download?id=
   blocked=blocked.txt;blocked.ncu
   blocked_result=blocked.result.txt
   store_prescript_to=./PRESCRIPT
   userAgent=Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/129.0.0.0 Safari/537.36
   secChUa="Chromium";v="129", "Not:A-Brand";v="24", "Google Chrome";v="129"
   urlAggressorServices=https://webportal.nrada.gov.ua/perelik-servisiv-derzhavy-agresora/#perelik
   AggressorServices_SOURCE_DOMAIN=webportal.nrada.gov.ua
   AggressorServices_PRIMARY_PDF_NAME=Perelik.#450.2023.07.06.pdf
   AggressorServices_prescript_to=./PRESCRIPT/MANUAL
   SERVICE_SUBDOMAINS=www,ftp,mail,api,blog,shop,login,admin,web,secure,m,mobile,app,dev,test,m
   ban_keywords=блокування|обмеження доступу|реалізацію.*обмежувальних
   unban_keywords=розблокування|припинення тимчасового
   max_file_size_bytes=10485760   
   ```
## Використання
1. **Збірка JAR**:
   ```bash
   mvn clean package
   ```
2. **Запуск утиліти**:
   - Звичайний режим:
     ```bash
     java -jar target/cip_gov_ua_getter-3.0-all.jar
     ```
   - Дебаг-режим:
     ```bash
     java -jar target/cip_gov_ua_getter-3.0-all.jar -d
     ```
3. **Результати**:
   - Вкладення зберігаються в `store_prescript_to` (наприклад, `./PRESCRIPT`).
   - Список доменів, включно з сервісами агресора, — у `blocked.result.txt`.
   - Логи — у `logs/cip_gov_ua_getter.log`.
### Приклад вихлопу
- `blocked.result.txt`:
  ```
  example.com
  test.org
  xn--80ak6aa92e.com
  aggressor-service.ru
  ```
- Лог із `-d`:
  ```
  2025-04-16 10:00:00 INFO  n.u.cip_gov_ua_getter - Fetching prescript for ID 68502 from server
  2025-04-16 10:00:00 DEBUG n.u.cip_gov_ua_getter - Blocked static resource: https://cip.gov.ua/content/css/loading.css
  2025-04-16 10:00:00 INFO  n.u.cip_gov_ua_getter - Successfully downloaded PDF to: /home/olden/.../MANUAL/Perelik.#450.2023.07.06.pdf
  2025-04-16 10:00:01 INFO  n.u.cip_gov_ua_getter - Successfully stored blocked domains to blocked.result.txt
  ```
### Конфігурація логування
Логи виводяться в консоль і зберігаються в `logs/cip_gov_ua_getter.log` з щоденною ротацією (30 днів). Налаштування логування задаються в `src/main/resources/logback.xml`. Основні особливості:
- Рівень `INFO` за замовчуванням: чисті логи без зайвих деталей.
- Режим `-d` вмикає рівень `DEBUG` для пакету `net.ukrcom.cip_gov_ua_getter` — ідеально для діагностики.
- Надлишкові дебаг-повідомлення від PDFBox/FontBox прибрано (залишаємо лише важливе!).
Щоб змінити шлях до логів або період ротації, відредагуйте `logback.xml`. Наприклад, змініть `<file>logs/cip_gov_ua_getter.log</file>` на потрібний шлях.
**Створення конфігурації**: Створіть файл `cip.gov.ua.properties` у корені проекту. Приклад із поясненнями:
```
# URL для API зі списком розпоряджень
urlArticles=https://cip.gov.ua/services/cm/api/articles?page=0&size=1000&tagId=60751
# URL для завантаження вкладень
urlPrescript=https://cip.gov.ua/services/cm/api/attachment/download?id=
# Вхідні файли з доменами (через ; для кількох файлів)
blocked=blocked.txt;blocked.ncu
# Вихідний файл із результуючим списком доменів
blocked_result=blocked.result.txt
# Папка для збереження вкладень
store_prescript_to=./PRESCRIPT
# HTTP User-Agent для запитів (імітує браузер)
userAgent=Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/129.0.0.0 Safari/537.36
# Sec-Ch-Ua для JavaScript-запитів (імітує Chrome)
secChUa="Chromium";v="129", "Not:A-Brand";v="24", "Google Chrome";v="129"
# URL для парсингу сервісів держави-агресора
urlAggressorServices=https://webportal.nrada.gov.ua/perelik-servisiv-derzhavy-agresora/#perelik
# Домен джерела для відносних PDF-посилань
AggressorServices_SOURCE_DOMAIN=webportal.nrada.gov.ua
# Ім'я PDF-файлу для сервісів агресора
AggressorServices_PRIMARY_PDF_NAME=Perelik.#450.2023.07.06.pdf
# Папка для збереження PDF
AggressorServices_prescript_to=./PRESCRIPT/MANUAL
# Субдомени для видалення (через кому)
SERVICE_SUBDOMAINS=www,ftp,mail,api,blog,shop,login,admin,web,secure,m,mobile,app,dev,test
```
### Як працює валідація доменів
Утиліта ретельно перевіряє кожен домен, щоб гарантувати коректність списку для блокування:
- **Очищення**: Видаляються протоколи (`https://`, `ftp://`), субдомени (`www`, `mail` тощо), шляхи (`/path`), порти (`:8080`) та параметри (`?key=value`).
- **Перевірка довжини**: Домени довші за 255 символів відкидаються (до і після Punycode).
- **Валідація TLD**: Використовується `commons-validator` для перевірки доменів верхнього рівня.
- **Обробка гомогліфів**: Нелатинські символи (наприклад, кирилиця) нормалізуються через `icu4j` (`SpoofChecker`) і конвертуються в Punycode (`IDN.toASCII`).
- **Фільтрація IP**: IP-адреси пропускаються, адже нас цікавлять лише домени.
- **Кешування**: Використовується `ConcurrentHashMap` для швидкої обробки гомогліфів.
Результат: чистий список валідних доменів у `blocked.result.txt`, готовий для DNS-блокування.
## Нотатки для розробників
- **Залежності**:
  - Playwright 1.51.0 (Apache License 2.0)
  - commons-validator 1.9.0 (Apache License 2.0)
  - icu4j 77.1 (Unicode License)
  - logback-classic 1.5.18 (EPL 1.0/LGPL 2.1)
  - json 20250107 (JSON License)
  - pdfbox 3.0.3 (Apache License 2.0)
  - jsoup 1.18.1 (MIT License)
- **Логіка роботи**:
  - `CGUGetter`: Завантажує JSON із розпорядженнями.
  - `GetPrescript`: Завантажує/читає вкладення, валідує домени.
  - `AggressorServicesParser`: Парсить PDF із сервісами держави-агресора.
  - `BlockedObjects`: Формує список заблокованих доменів.
  - `BlockedDomain`/`BlockedDomainComparator`: Зберігає та сортує домени.
- **Майбутні ідеї**:
  - Кешування JSON для зменшення запитів до API.
  - Паралельна обробка вкладень (з обережністю через ризик блокування).
  - Додавання підтримки `.woff`, `.ttf` до блокування ресурсів.
- **Посилання для вивчення**:
  - Jackson JSON Parser
  - JSON Parsing in Java
## Відомі проблеми
- Перший запуск може тривати ~30-35 хвилин через завантаження всіх вкладень.
- Потрібна стабільна мережа, інакше запити можуть завершитися помилкою (записуються в `failed_ids.txt`).
- Debian 11 видає попередження про застарілий WebKit. Рекомендується оновити ОС.
### FAQ
**Чому перший запуск такий довгий?**  
Перший запуск завантажує всі вкладення з API cip.gov.ua, що може зайняти 30-35 хвилин залежно від мережі. Наступні запуски використовують локальний кеш (`PRESCRIPT`) і виконуються за ~6 секунд.
**Як перевірити, які домени додалися?**  
Відкрийте `blocked.result.txt` — там список валідних доменів. У дебаг-режимі (`-d`) логи в `logs/cip_gov_ua_getter.log` покажуть деталі валідації.
**Що робити, якщо API не відповідає?**  
Перевірте мережу та логи в `failed_ids.txt`. Спробуйте повторити запуск або використайте локальний кеш.
**Чому PDF із сервісів агресора не завантажується?**  
Переконайтеся, що `urlAggressorServices` і `AggressorServices_SOURCE_DOMAIN` у `cip.gov.ua.properties` коректні. Логи вкажуть на проблему (наприклад, 404).
**Як вимкнути логування у файл?**  
Відредагуйте `logback.xml`, прибравши `<appender-ref ref="FILE" />` із потрібних логерів.
### Внесок у проєкт
Хочете зробити утиліту ще крутішою? 😎 Ми відкриті до ідей, патчів і пропозицій! Ось як можна долучитися:
- **Повідомте про баг**: Створіть [issue](https://github.com/oldengremlin/cip_gov_ua_getter/issues) з описом проблеми.
- **Запропонуйте фічу**: Поділіться ідеєю в issues — від паралельної обробки до підтримки нових форматів.
- **Надішліть Pull Request**: Форкніть репо, зробіть зміни і надішліть PR. Не забудьте описати, що ви додали!
- **Переклад документації**: Допоможіть перекласти `README.md` чи `LICENSE-UKR.md` іншими мовами.
Перед внеском ознайомтеся з [Apache License 2.0](LICENSE). Давайте будувати велосипеди разом! 🚴
## Ліцензія
Apache License 2.0. Див. [LICENSE](LICENSE) та [NOTICE](NOTICE).  
Пояснення українською: [LICENSE-UKR.md](LICENSE-UKR.md).
## Контакти
Питання, баги, ідеї? Відкривайте [issues](https://github.com/oldengremlin/cip_gov_ua_getter/issues) в репозиторії.
---
## Version History
**Version 3.1.7**
- Покращено обробку довгих імен файлів у `GetPrescript`:
  - У `setOrigFileName` додано обрізку до останнього пробілу, щоб уникнути обрізаних слів (наприклад, `зах` → `обмежувальних`).
  - Додано `...` перед розширенням для обрізаних імен (наприклад, `...обмежувальних....pdf`).
  - Додано перевірку на заборонені символи (`\/:*?"<>|`) з заміною на `id_prescript.ext`.
  - У `trimToUtf8Bytes` додано підтримку сурогатних пар (емодзі, рідкісні символи).
- Покращено `storePrescriptTo`:
  - Збільшено ліміт вільного місця до `MAX_FILE_SIZE_BYTES_DEFAULT * 2` (~31.5 МБ).
  - Додано логування стеку `IOException` у дебаг-режимі.
- Покращено логування:
  - У `executeAjaxRequest` змінено `logger.warn` на `logger.debug` для `File size` і `dataUrl length`.
  - У `trimToUtf8Bytes` збережено детальне логування з оригінальним рядком.
- Додано рекомендацію: використовувати скрипт для чистки дублів у кеші:
  ```bash
  for id in $(ls *~*.pdf | cut -d'~' -f1 | sort | uniq -d); do
      original=$(ls ${id}~* | grep -E '\.pdf$' | head -n1)
      ls ${id}~* | grep -v "$original" | xargs -I {} rm -v {}
  done
  ```
- Збережено зчитування `cip.gov.ua.properties` через `InputStream` для сумісності з `\uXXXX`.
- Додано примітку: для тестування довгих імен запускати з дебаг-режимом (`-d`) і перевіряти логи на `Trimmed inString` і `Cleaned origFileName`.
- Додано підтримку сурогатних пар (емодзі, рідкісні символи) у `trimToUtf8Bytes` для захисту від незвичайних імен файлів.
- Покращено `setOrigFileName`:
  - Обрізка до останнього пробілу для читачних імен (наприклад, `обмежувальних....pdf` замість `зах.pdf`).
  - Додано `...` перед розширенням.
  - Обробка невалідних символів (`\/:*?"<>|`) з заміною на `id_prescript.ext` або `.unknown`.
- Змінено `logger.warn` на `logger.debug` для некритичних повідомлень у `storePrescriptTo` і `executeAjaxRequest`.
- Підтверджено ефективність bash-скрипта для чистки дублів у кеші.
**Version 3.1.6**
- Виправлено обробку довгих імен файлів у `GetPrescript`:
  - Додано метод `trimToUtf8Bytes` для обрізки імен файлів до 250 байт у UTF-8, зберігаючи цілісність символів.
  - Оновлено `setOrigFileName`: обрізається тільки основна частина імені (без розширення), розширення додається без дублювання крапки.
  - Прибрано агресивні заміни символів (`.replaceAll("[^a-zA-Z0-9а-яА-Я._-]", "_")` і `.replaceAll("\\s+", "_")`), щоб уникнути дублювання файлів у кеші.
  - Додано дебаг-логування обрізки імен файлів у `trimToUtf8Bytes`.
- Покращено `storePrescriptTo`:
  - Додано перевірку вільного місця на диску (мінімум 10 МБ).
  - Збережено перевірку прав доступу до директорії `./Prescript`.
  - Додано логування стеку винятку `IOException` у дебаг-режимі.
- Збережено зчитування `cip.gov.ua.properties` через `InputStream` для простоти і сумісності з `\uXXXX`.
- Додано примітку в документацію про можливі проблеми з довгими іменами файлів у Linux (обмеження 255 байт у ext4) і рекомендацію вмикати дебаг-режим для діагностики.
- Рекомендація: перед зміною логіки `setOrigFileName` запускати прогін із дебаг-режимом (`-d`), щоб відстежити зміни імен файлів.
**Version 3.1.5**
- Виправлено збереження PDF-файлів у `GetPrescript`:
  - Очищення імен файлів: заміна пробілів на `_`, видалення проблемних символів, обрізання до 100 символів із збереженням розширення.
  - Додано перевірку прав доступу до директорії `./Prescript` і вільного місця на диску.
  - Покращено логування: додано повний стек винятку в дебаг-режимі, точна причина помилки (наприклад, "Directory not writable") записується в `failed_ids.txt`.
  - Виняток `IOException` у `FileOutputStream` тепер детально логуюється для діагностики.
- Залишено зчитування `cip.gov.ua.properties` через `InputStream`:
  - Підтверджено, що `\uXXXX` декодується коректно для `ban_keywords` і `unban_keywords`.
  - Додано примітку в документацію: для UTF-8 без ескейпів можна перейти на `InputStreamReader`.
- Збережено дефолтний ліміт `max_file_size_bytes` на 15 МБ.
- Додано примітку про можливі проблеми з довгими іменами файлів у Linux (обмеження 255 байт).
**Version 3.1.4**
- Виправлено обробку кирилиці в `cip.gov.ua.properties`:
  - Використовується `InputStreamReader` із UTF-8 для коректного декодування `\uXXXX` (Unicode-ескейпів) при редагуванні в NetBeans.
  - `ban_keywords` і `unban_keywords` тепер працюють із кирилицею, навіть якщо збережені як `\uXXXX`.
- Виправлено збереження PDF-файлів у `GetPrescript`:
  - Додано потокове завантаження через `page.request().get()` для бінарних файлів.
  - Покращено логування: точна причина помилки (наприклад, "File too large") записується в логи і `failed_ids.txt`.
  - Збільшено дефолтний ліміт `max_file_size_bytes` до 15 МБ.
- Додано коментар у `cip.gov.ua.properties` про `\uXXXX` при редагуванні в IDE.
- Перенесено ключові слова для фільтрації постів у `cip.gov.ua.properties`:
  - `ban_keywords`: Слова для постів про блокування (наприклад, `блокування|обмеження доступу|реалізацію.*обмежувальних`).
  - `unban_keywords`: Слова для постів про розблокування (наприклад, `розблокування|припинення тимчасового`).
  - Роздільник: `|`.
- Додано підтримку параметра `max_file_size_bytes` у `cip.gov.ua.properties` (дефолт: 15 МБ).
- Збережено фільтрацію за "блокування" та "обмеження доступу".
- Виправлено баг із пропуском доменів через сторонні символи (наприклад, `nasepravda.cz,` чи `kscm.cz;`).
- Оновлено `DOMAIN_CLEAN_PATTERN`: додано підтримку подвійних дефісів для Punycode-доменів.
- Додано кешування TLD у `DomainValidatorUtil` для прискорення перевірки TLD.
- Збережено повну підтримку Unicode для всіх мов.
- Підтримка кількох доменів у строці (наприклад, `nasepravda.cz,example.com`).
- Покращено логування для діагностики.
**Version 3.1.3**
- Перенесено ключові слова для фільтрації постів у `cip.gov.ua.properties`:
  - `ban_keywords`: Слова для постів про блокування (наприклад, `блокування|обмеження доступу|реалізацію.*обмежувальних`).
  - `unban_keywords`: Слова для постів про розблокування (наприклад, `розблокування|припинення тимчасового`).
  - Роздільник: `|`.
- Додано підтримку параметра `max_file_size_bytes` у `cip.gov.ua.properties` для налаштування максимального розміру файлів (дефолт: 10 МБ).
- Покращено логування для надто великих файлів у `GetPrescript` із зазначенням розміру.
- Додано підтримку нових назв розпоряджень із ключовими словами "реалізацію" та "обмежувальних".
- Збережено фільтрацію за "блокування" та "обмеження доступу".
- Виправлено баг із пропуском доменів через сторонні символи (наприклад, `nasepravda.cz,` чи `kscm.cz;`).
- Оновлено `DOMAIN_CLEAN_PATTERN`: додано підтримку подвійних дефісів для Punycode-доменів (наприклад, `xn--b1akbpgy3fwa.xn--p1acf`).
- Додано кешування TLD у `DomainValidatorUtil` для прискорення перевірки повторюваних TLD (наприклад, `.cz`, `.com`).
- Збережено повну підтримку Unicode для всіх мов (кирилиця, китайська, арабська тощо).
- Підтримка кількох доменів у строці (наприклад, `nasepravda.cz,example.com`).
- Покращено логування для діагностики очищення доменів.
**Version 3.1.2**
- Додано підтримку нових назв розпоряджень із ключовими словами "реалізацію" та "обмежувальних" (наприклад, «Про реалізацію і моніторинг ефективності персональних спеціальних економічних та інших обмежувальних заходів (санкцій)»).
- Збережено фільтрацію за "блокування" та "обмеження доступу".
- Виправлено баг із пропуском доменів через сторонні символи (наприклад, `nasepravda.cz,` чи `kscm.cz;`).
- Оновлено `DOMAIN_CLEAN_PATTERN`: додано підтримку подвійних дефісів для Punycode-доменів (наприклад, `xn--b1akbpgy3fwa.xn--p1acf`).
- Додано кешування TLD у `DomainValidatorUtil` для прискорення перевірки повторюваних TLD (наприклад, `.cz`, `.com`).
- Збережено повну підтримку Unicode для всіх мов (кирилиця, китайська, арабська тощо).
- Підтримка кількох доменів у строці (наприклад, `nasepravda.cz,example.com`).
- Покращено логування для діагностики очищення доменів.
**Version 3.1.1**
- Виправлено баг із пропуском доменів через сторонні символи (наприклад, `nasepravda.cz,` чи `kscm.cz;`).
- Оновлено `DOMAIN_CLEAN_PATTERN`: додано підтримку подвійних дефісів для Punycode-доменів (наприклад, `xn--b1akbpgy3fwa.xn--p1acf`).
- Додано кешування TLD у `DomainValidatorUtil` для прискорення перевірки повторюваних TLD (наприклад, `.cz`, `.com`).
- Збережено повну підтримку Unicode для всіх мов (кирилиця, китайська, арабська тощо).
- Підтримка кількох доменів у строці (наприклад, `nasepravda.cz,example.com`).
- Покращено логування для діагностики очищення доменів.
**Version 3.1**
- Уніфіковано валідацію доменів через `DomainValidatorUtil`.
- Оптимізовано обробку шляхів із `java.nio.file.Path`.
- Покращено логування: прибрано надлишкові дебаг-повідомлення, додано вивід у `logs/cip_gov_ua_getter.log`.
- Зберігаємо KISS: чистий код, прозора логіка. 😎
**Version 3.0 (2025-04-16)**
- Додано парсинг сервісів держави-агресора з `webportal.nrada.gov.ua`, домени додаються до `blocked.result.txt`.
- Уніфіковано обробку гомогліфів із використанням `SpoofChecker`.
**Version 2.4 (2025-04-16)**
- Додано блокування статичних ресурсів (`.jpg`, `.jpeg`, `.png`, `.svg`, `.woff2`, `.css`).
- Покращено продуктивність: ~6 секунд для кешованих запусків.
- Додано дебаг-режим із детальними логами (`-d`).
- Оптимізовано логування: чисті логи на `INFO`, деталі на `DEBUG`.
